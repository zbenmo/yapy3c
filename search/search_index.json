{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Yet Another Python3 Course (YAPY3C)","text":"<p>My name is Oren, and I'll be your instructor.</p> <p>You can contact me at 'zbenmo@gmail.com'.</p>"},{"location":"part_I/","title":"Part I","text":"<p>In Part I we learn the basics, data types, and the structure of a program.</p> <p>Let\u2019s get an access to a Python environment. The following should work for you:</p> <p>https://www.python.org/shell/</p> <p>(You are most welcome to use JupyterLab or an editor of your choice and to run your Python scripts with 'python my_script.py', as an example, if you already know your way.)</p> <p>There are a few versions of Python, we\u2019ll use Python 3. Let\u2019s make sure this is what we have. run there (in your shell):</p> <pre><code>import sys\nprint(sys.version)\n</code></pre> <p>For me it printed: 3.8.0, which is good.</p> <p>You see above, that we had to import 'sys'. Otherwise sys wasn\u2019t available. Once we imported it, sys.version was the version of the current Python interpreter (the running environment above). The print statement just shows us what we\u2019ve imported. We did not need to import anything special to have \u2018print\u2019.</p> <p>Let\u2019s try just</p> <pre><code>sys.version\n</code></pre> <p>It also prints the value (3.8.0 for me). This is as we\u2019re in an interactive shell, but generally, unless we print something, an expression, as sys.version, or 3 + 4, is just yet another expression, and does not show in the output. We can omit the 'print' here, as in this exercise, we\u2019ll be in the interactive shell. Let\u2019s try:</p> <pre><code>3 + 4\n</code></pre> <p>We get a new value. To see the type of a value, we use for example:</p> <pre><code>type(3)\n</code></pre> <p>We get:</p> <p><code>&lt;class 'int'&gt;</code>  (an integer)</p> <p>What about \u2018hello\u2019, what is its type?</p> <p>We get:</p> <p><code>&lt;class 'str'&gt;</code> (a string)</p> <p>If you happen to use \u201chello\u201d it should be the same, both should work.</p> <pre><code>my_list = [1, 2, 4]\ntype(my_list)\n</code></pre> <p>We should get:</p> <p><code>&lt;class 'list'&gt;</code></p> <p>Note above, that we assigned the value into a variable, my_list. This is handy as to use later in a program.</p> <p>A list can be also constructed as follows:</p> <pre><code>list('hello')\n</code></pre> <p><code>['h', 'e', 'l', 'l', 'o']</code></p> <p>The characters in the string became each an element in the list.</p> <p>With lists you can take slices, we\u2019ll use the variable my_list from above to demonstrate:</p> <pre><code>my_list[1:]\n</code></pre> <p><code>[2, 4]</code></p> <pre><code>my_list[:2]\n</code></pre> <p><code>[1, 2]</code></p> <p>Clarification: a single element, for example the first, will be my_list[0], a slice can be for example my_list[1:4], or as above (1:, means from the second to the end, and :2 means up to but not including index 2, therefore the first two elements).</p> <p>Note: the first index is 0. So the valid indices for a list \u2018lst\u2019 are: 0..len(lst) - 1 (ex. when len(lst) == 3 then the valid indices are 0, 1, 2).</p> <p>Slices are also lists, try to get the type of a slice.</p> <p>A list can be of mixed types, and also nested:</p> <pre><code>[1, 'Dog', my_list]\n</code></pre> <p><code>[1, 'Dog', [1, 2, 4]]</code></p> <p>But usually, we\u2019ll use lists where the elements are of the same type.</p> <p>Let\u2019s have a function:</p> <pre><code>def add(a, b):\nreturn a + b\nadd(1, 4)\n</code></pre> <p><code>5</code></p> <pre><code>add('abc', 'def')\n</code></pre> <p><code>'abcdef'</code></p> <pre><code>add(1, 'def')\n</code></pre> <pre><code>Traceback (most recent call last):\n File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n File \"&lt;stdin&gt;\", line 2, in add\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n</code></pre> <p>So we\u2019ve seen that the same function, add, was good for integers and for strings. For strings \u2018+\u2019 means concatenation. When we tried mixed arguments. The call started as expected, but then \u2018+\u2019 is not defined between an integer and \u2018str\u2019. And so we got an error, or as it is called in Python an exception. If we wrote it in a software product, this would either be considered a bug, or it can be handled in run time, with some more control flow constructs (later).</p> <p>We can solve it by converting the integer first to a string:</p> <pre><code>str(1) + 'def'\n</code></pre> <p><code>'1def'</code></p> <p>If we look for a second at the definition of the function above, we see that we\u2019ve started with the word \u2018def\u2019, then gave the name of the new function, then a parameters list in parentheses, then the column, and inside the function commands were indented with a tab or a few spaces. The last statement in a function is often return with the calculated value as the output of the function.</p> <pre><code>type(add)\n</code></pre> <p><code>&lt;class 'function'&gt;</code></p> <p>And we can also assign a function to a variable (note: not adding the parentheses   as in a call). The variable can later be activated (called).</p> <pre><code>a_func = add\na_func(9, 8)\n</code></pre> <p><code>17</code></p> <p>Remember, every time you have a value or a variable and you are not sure what it is, debug by printing its type.</p> <pre><code>print(type(print))\n</code></pre> <p><code>&lt;class 'builtin_function_or_method'&gt;</code></p> <pre><code>print(type(sys))\n</code></pre> <p><code>&lt;class 'module'&gt;</code></p> <pre><code>print(type(5 / 2))\n</code></pre> <p><code>&lt;class 'float'&gt;</code></p> <p>It is not anymore an integer. Dividing an integer by another integer results in a float.</p> <pre><code>5 // 2\n</code></pre> <p><code>2</code></p> <p>Here the result is an integer, and it wasn\u2019t rounded but rather truncated.</p> <p>We\u2019ve seen before the type list, that is very useful. Another useful type is a dictionary, or dict. It is also referred to sometimes as associative memory. You have keys, and you have values. In a list, you use indices to address the content. Otherwise it is similar.</p> <pre><code>{'a': 4, 'b': 'Vier'} # One way to create a 'dict'\nmy_dict = dict() # yet another way to create a 'dict'\nmy_dict['my_key'] = 'your_value'\nmy_dict\n</code></pre> <p><code>{'my_key': 'your_value'}</code></p> <p>We have added an entry here to an existing dictionary. To add values to a list, we can for example do:</p> <pre><code>my_list.append('Marshmello')\nmy_list\n</code></pre> <p><code>[1, 2, 4, 'Marshmello']</code></p> <p>There is also a useful type, a tuple. For example:</p> <pre><code>my_tuple = (1, 3, 'g')\nmy_tuple\n</code></pre> <p><code>(1, 3, 'g')</code></p> <pre><code>type(my_tuple)\n</code></pre> <p><code>&lt;class 'tuple'&gt;</code></p> <p>You can access elements of a tuple as you do with a list, yet a tuple is an immutable sequence.</p> <pre><code>my_tuple[0] = 2\n</code></pre> <pre><code>Traceback (most recent call last):\n File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n</code></pre> <pre><code>my_tuple.append('Baby')\n</code></pre> <pre><code>Traceback (most recent call last):\n File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'tuple' object has no attribute 'append'\n</code></pre> <p>Tuples are useful in many cases. For example we can assign values to two variables at the same time.</p> <pre><code>old, new = 'Trump', 'Biden'\n</code></pre> <p>Here the parentheses are implicit. Also, sometimes a function can return multiple values, and this can be done with returning a \u2018dict\u2019, or a \u2018list\u2019, but also sometimes as a tuple.</p> <pre><code>for k, v in my_dict.items():\nprint(k, v)\n</code></pre> <p><code>my_key your_value</code></p> <p>Note, above is a for loop. Its structure somewhat resembles a function definition (the column, and the indentation). We got here two loop variables, k and v, as the function items of \u2018dict\u2019 instances returns an iterator of two values each iteration. We then printed those two in one \u2018print\u2019 statement. We happened to have only one key-value pair in the dictionary above.</p> <p>Here is another example of a 'for' loop:</p> <pre><code>my_sum = 0\nfor i in range(3):\nmy_sum += i\nmy_sum\n</code></pre> <p><code>3</code></p> <p>We initialized my_sum to zero, then we added 0, 1, and finally 2, to get 3.</p> <pre><code>type(range(3))\n</code></pre> <p><code>&lt;class 'range'&gt;</code></p> <p>range resembes a list of consequtive integers that is not mutable. We did not need to create and initialize a list, and also the 'range' has the advantage that it keeps its values in its \"stomach\", and only makes them available when we iterate over it. If we want the explicit values, we can do:</p> <pre><code>list(range(5))\n</code></pre> <p><code>[0, 1, 2, 3, 4]</code></p> <p>We could have done above also simpler, by using the builtin function \u2018sum\u2019:</p> <pre><code>sum(range(3))\n</code></pre> <p><code>3</code></p> <p>Here is a small example of a function that returns two values, using the builtin functions \u2018min\u2019, and \u2018max\u2019.</p> <pre><code>def min_and_max(a_list):\nreturn min(a_list), max(a_list)\nmin_and_max(range(6))\n</code></pre> <p><code>(0, 5)</code></p> <pre><code>min_and_max([4, 1, 3])\n</code></pre> <p><code>(1, 4)</code></p> <p>Next we\u2019ll see boolean conditions and an if statement. This is also very important to control the flow of the program.</p> <pre><code>len(my_list)\n</code></pre> <p><code>4</code></p> <p>So the built-in function 'len' gives the length of a list. Good to know!</p> <pre><code>if len(my_list) &gt; 3:\nprint('it is')\n</code></pre> <p><code>it is</code></p> <p>And the type of the expression: len(my_list) &gt; 3, is:</p> <pre><code>type(len(my_list) &gt; 3)\n</code></pre> <p><code>&lt;class 'bool'&gt;</code></p> <p>Below is a function to reverse a string (or a list), and a call to that function.</p> <pre><code>def my_reverse(a_string):\nif len(a_string) &lt; 2:\nreturn a_string\nelse:\nreturn my_reverse(a_string[1:]) + a_string[0:1]\nmy_reverse('maar')\n</code></pre> <p>'raam'</p> <pre><code>my_reverse([3, 4, 5])\n</code></pre> <pre><code>[5, 4, 3]\n</code></pre> <p>Note, the implementation of the above function, is based on the function itself. This kind of implementation is called recursion. Recursion is a bit more advanced way of writing stuff, but sometimes it is actually simpler. If using recursion, pay attention to a stopping condition. The problems should become simpler and simpler, and in the final steps, you should return a simple value, as was the case above when the string was short and its reverse is actually the same value.</p> <p>I\u2019ve checked the builtin \u2018reversed\u2019 function. It behaves a little differently for a list, or for a string.</p> <pre><code>list(reversed([1,2,3]))\n</code></pre> <pre><code>[3, 2, 1]\n</code></pre> <pre><code># this is what we had before\nlist(reversed('gadol'))\n</code></pre> <pre><code>['l', 'o', 'd', 'a', 'g']\n</code></pre> <pre><code># but for a string, we\u2019ll get the list of characters (reversed).\n</code></pre> <p>BTW, \u2018#\u2019 and then text is a comment, and can be used in a program to help the reader follow the logic. \u2018#\u2019 can start after some other code, and from there it is a comment.</p> <p>Strings, have some functionality that we\u2019ve not explored before, for example:</p> <pre><code>\"hello\".upper()\n</code></pre> <pre><code>'HELLO'\n</code></pre>"},{"location":"part_I/#exercise","title":"Exercise","text":"<p>The exercise will be to approximate \ud835\udf45 by sampling. Let\u2019s say we have a circle with radius 1. What is its area? Now take a 1 by 1 square. And draw there a quarter of the above circle. The origin <code>(0, 0)</code> is the center of the (quarter) circle. The area of the square is <code>1 * 1 == 1</code>. The area of the quarter circle is <code>\ud835\udf45 / 4</code>. Let\u2019s sample a point from the rectangle. We\u2019ll do that by sampling x between 0 and 1, and y between 0 and 1. If <code>(x, y)</code> falls within the quarter circle, we\u2019ll count it in, otherwise, we\u2019ll not count it. After enough samples, the number of counted points, divided by the total number of samples, should approximate <code>\ud835\udf45 / 4</code>. As a check of your work, compare the value that you got for \ud835\udf45 (after multypling by 4) to the number you get from:</p> <pre><code>import math\nmath.pi\n</code></pre> <p>Guidance:</p> <p>The following code demonstrates sampling random numbers between 0 and 1 (each of type float). Remember that you need for each iteration two random numbers, one for x and another for y, and that the point <code>(x, y)</code> is at square distance of <code>x ** 2 + y ** 2</code> from the origin:</p> <pre><code>import random\nx, y = random.random(), random.random()\nsquare_distance = x ** 2 + y ** 2\n</code></pre> <p>Implement your code as a function that receives a parameter for the number of trials, and returns the approximated \ud835\udf45. It is a good idea to write the code in an editor of your preference, and to paste the code to the interactive Python shell, so you can avoid retyping the code for each fix.</p>"},{"location":"part_III/","title":"Part III","text":"<p>In this part of the course, we'll learn some more pure Python. We'll revisit some of the types and constructs we've seen before and learn some new tricks. We're also going to touch some bits and bobs that are nice to know and just waited till now.</p> <p>Let's look at the following code snippet.</p> <pre><code>def scan(a, b, c):\n\"Does something interesting with the arguments passed to it in the parameters 'a', 'b', and 'c'\"\nfor num in range(a, b):\nfor add in range(c):\nprint(num + add, end=', ')\nprint()\nscan(2, 5, 7)\n</code></pre> <pre><code>2, 3, 4, 5, 6, 7, 8, \n3, 4, 5, 6, 7, 8, 9, \n4, 5, 6, 7, 8, 9, 10, \n</code></pre> <p>The first observation I would like us to note is the string being the first expression of the function (\"Does something ..\"). This is a string like any other string, it is not a comment. And yet it is serving as a comment for the programmer, and for tools that help us edit, debug, and document the function. Those strings are called docstrings.  There is no issue in introducing those strings at the beginning of a function. You can introduce any expression anywhere you want in your program, this expression may be evaluated (depending on the program's control flow), and the program shall continue to the next expression (given that the expression does not raise an exception etc.). Having a string as the first expression had a special meaning and this convention is well integrated in the language and ecosystem.</p> <p>We note that 'range' can accept more than one argument. When two arguments are given, the first is the starting point, and the second is the value beyond the last value in the range. So 'range(3)' is equivalent to 'range(0, 3)'.</p> <p>We see a nested loop above. Note that importance of indentation. We must be exact with our indentation. When we return to a previous level, we should be in the exact column of the desired level. For example in line 7 the 'print' happens outside the add loop.</p> <p>BTW, a string (any strings) can be given in multiple lines, when it is wrapped with \"\"\" (or with '''). For docstring this is especially useful and often used.</p> <pre><code>def deep_neural_network(how_deep):\n\"\"\"\nThis function constructs a DNN based on your specification\nPlease take into consideration the benefits of a deep network,\nversus the downsides.\"\"\"\npass\n</code></pre> <p>Above, I defined a function, yet gave no implementation. I used 'pass' to indicate I have no implementation (at least for now). We need to add 'pass' to make the indentation clear. If we omit it, and start new expressions at the same indentation of the function's definition, the interpreter would complain that we forgot indentation.</p> <p>We can still call our function, exactly as expected, with:</p> <pre><code>deep_neural_network(5)\n</code></pre> <p>The return value is <code>None</code> which is an important value to know, it just stands for \"nothing\". It is useful in many places, as a default value, or just when we don't have anything better to assign, or to pass as an argument.</p> <p>In 'JupyterLab', which is the interactive Python that I'm using, I can do now:</p> <pre><code>deep_neural_network?\n</code></pre> <p>Which gives me:</p> <pre><code>Signature: deep_neural_network(how_deep)\nDocstring:\nThis function constructs a DNN based on your specification\nPlease take into consideration the benefits of a deep network,\nversus the downsides.\nFile:      /tmp/ipykernel_566/1092418094.py\nType:      function\n</code></pre> <p>We've already seen 'list's, 'dict's, and 'tuple's. Let's add to this winning team also 'set's.</p> <pre><code>s1 = set(\"hello\")\ns2 = set(\"bye\")\ns1, s2\n</code></pre> <p><code>({'e', 'h', 'l', 'o'}, {'b', 'e', 'y'})</code></p> <pre><code>s1 &amp; s2, s1 - s2, s2 - s1\n</code></pre> <p><code>({'e'}, {'h', 'l', 'o'}, {'b', 'y'})</code></p> <p>Note that sets use the same curly brackets as dicts, '{}'. You can initialize a set with curly brackets, as in:</p> <pre><code>nodes_visited_by_now = {'A', 'B', 'C'}\n</code></pre> <p>If you wish to assign an empty set to a variable, use 'set()', as an empty brackets '{}' will be interpreted with an empty dict.</p> <p>A lot of times, just by using those built-in containers you can achieve very complicated functionality. We will also learn in next parts to create our own classes (object oriented), yet most of your code can often be realized with the basic constructs, types, and containers, available for free in the language, familiar to your fellow programmers, and already tested and optimized for you. Try to avoid cluttering your program with too many new constructs and ideas. This is a least my recommendation, which I picked at the times I was using Ruby and following the Ruby's community. I think it is also very relevant to Python.</p> <p>There are a lot more goodies to learn about Python, we've only scratched the surface. Let's learn about comprehension.</p> <p>Consider this list of strings:</p> <pre><code>words = \"Welcome to my show!\".split(); words\n</code></pre> <p><code>['Welcome', 'to', 'my', 'show!']</code></p> <p>When we 'split' a string we get a list of strings, where the splitting character(s) are removed.</p> <p>Let's say we want to lower all words (we see that there is only one word, 'Welcome', at the moment but for arbitrary input we don't know in advance). The following code shall do the work:</p> <pre><code>words_lower = []\nfor word in words:\nwords_lower.append(word.lower())\nwords_lower\n</code></pre> <p><code>['welcome', 'to', 'my', 'show!']</code></p> <p>There is a very useful construct that is arguably more readable and may be even faster.</p> <pre><code>words_lower = [word.lower() for word in words]\n</code></pre> <p>words_lower is now a list with values as before, in our example, <code>['welcome', 'to', 'my', 'show!']</code>. Since the loop only serves for going over all the items in the list words we might as well have it inside the creation of the new list words_lower.  This construct is called list comprehension. With list comprehension we can also filter out values. For example, let's filter out words that are in the set <code>{'from', 'to', 'cc'}</code>.</p> <pre><code>words_filtered = [word for word in words_lower if word not in {'from', 'to', 'cc'}]; words_filtered\n</code></pre> <p><code>['welcome', 'my', 'show!']</code></p> <p>Note the condition at the end of the list comprehension, which allows only words that are not in the given set of words. We could have combine lower-casing the words and the filtering. Make your own judgement what is more readable given your situation.</p> <p>Let's find out how many characters in the following strings.</p> <pre><code>fruits = [\"apple\", \"banana\", \"orange\"]\nlens = {fruit: len(fruit) for fruit in fruits}; lens\n</code></pre> <p><code>{'apple': 5, 'banana': 6, 'orange': 6}</code></p> <p>Which shows us that we can use comprehensions also with 'dict's. We've built a new dict on-the-fly while iterating over the entries in fruits.</p> <p>In the next example, we'll calculate a \"reverse index\" to a given dict.</p> <pre><code>roman_numbers = {'I': 1, 'V' : 5, 'X': 10}\narabic_numbers = {v: k for k, v in roman_numbers.items()}; arabic_numbers\n</code></pre> <p><code>{1: 'I', 5: 'V', 10: 'X'}</code></p> <p>If we wrap an iterable, such as a list, with 'enumerate', we get a new iterable that gives us tuples. The first component of a tuple is the index of the matching item, and the second component is the original item in the original iterable. A picture (code snippet) is worth a thousand words:</p> <pre><code>enumerate(list(\"groceries\"))\n</code></pre> <p><code>&lt;enumerate at 0x7f1b05a48480&gt;</code></p> <p>We turned a string into a list or characters and wrapped it with an 'enumerate'. The output tells us that now we have an 'enumerate'. To show the values, we can construct a list out of the 'enumerate' object we have. We could have iterated over the 'enumerate' or use it in a comprehension expression. The list construction will serve us here.</p> <pre><code>list(enumerate(list(\"groceries\")))\n</code></pre> <pre><code>[(0, 'g'),\n (1, 'r'),\n (2, 'o'),\n (3, 'c'),\n (4, 'e'),\n (5, 'r'),\n (6, 'i'),\n (7, 'e'),\n (8, 's')]\n</code></pre> <p>And we see our expected tuples.</p> <p>Time for a small example. Let's build a function that takes a roman number as a string and returns the equivalent number.</p> <pre><code>def from_roman(roman):\n\"\"\"\n    This function receives a roman number as a string and returns the number.\n    &gt;&gt;&gt; from_roman(\"VII\")\n    7\n    &gt;&gt;&gt; from_roman(\"IV\")\n    4\n    &gt;&gt;&gt; from_roman(\"XIV\")\n    14\n    &gt;&gt;&gt; from_roman(\"XVIII\")\n    18\n    &gt;&gt;&gt; from_roman(\"MMM\")\n    ValueError                                Traceback (most recent call last)\n        ...\n    ValueError: Don't know to handle 'M'.    \n    \"\"\"\nmapping = {'I': 1, 'V': 5, 'X': 10}\narabic = 0\nprev_val = 0\nfor c in reversed(roman):\nval = mapping.get(c, None)\nif val is None:\nraise ValueError(f\"Don't know to handle '{c}'.\")\nif val &gt;= prev_val:\narabic += val\nelse:\narabic -= val\nprev_val = val\nreturn arabic\n</code></pre> <p>My logic above was to go from right to left, to add when we see the same value or a bigger value (ex. from I to V), and to subtract when we see a smaller value (ex. from V to I).</p> <p>To go from right to left, I've wrapped the input string roman with 'reversed'. 'reversed' is an iterable that gives us the items in a reversed order. When accessing my mapping dict, I have used 'get' rather than indexing notation as to avoid an exception when a key is not present. But then I have \"manually\" raises an exception of type 'ValueError' when we got a character that is not currently supported. Note the f-string used when creating the exception. f-strings are a template, and we fill the values in, between currly brackaets, with Python expression. This is very convenient way to format a string.</p> <p>The '+=' and '-=' operators are used here and mean the same as is the case in the C language. Try to avoid using those special operators when working with complex objects, yet for simple variables of type integer in this example, this should work perfectly.</p> <p>The reason it may be risky to use '+=' and '-=' with objects is that a lot of times there is not explicit implementation of the operator. Then the operator '+=', as an example, is implicitly converted for example to <code>a = a + 1</code> which while seems benign actually results in a new object begin assigned to a in the example. If some other variable or data structure (for example a dict) used to reference a one may believe they have the handle to the up-to-date a yet it is not the case. They are probably still referencing the old a. Just keep that in mind.</p> <p>Last thing to notice is that I've added examples in the docstring. This are of the form <code>&gt;&gt;&gt; expression (newline) expected output</code>. This adds clarity for the intended use, it becomes part of the documentation. But there is more! One can actually execute those tests with Python built-in doctest.</p> <p>In a lot of Python file, you'll find a 'main' function, and toward the bottom of the file, an 'if' statement:</p> <pre><code>def main():\n...\nif __name__ == \"__main__\":\nmain()\n</code></pre> <p>When you run the file with <code>python my_file.py</code> the expression in the bottom is evaluated to True and the code in the main function is executed. When the 'if' statement is missing, code in functions is not called, so you may end up not really running anything. Only code outside functions is executed. It is a good practice to wrap your code in functions and call the starting point, say, main, from such an 'if' statement. A file with only functions can still be useful as a part of a module (and be called from outside the file, or from the command line with the -m flag).</p> <p>Whole this long detour was to show the following:</p> <pre><code>... # code containing potentially doctests\nif __name__ == \"__main__\":\nimport doctest\ndoctest.testmod()\n</code></pre> <p>The snippet above should look for doctests in the file and should execute them, verifying the output.</p> <p>There is yet another very useful function when we're dealing with sequences (a list for example) and iterations. 'zip' allows us to traverse multiple lists, as an example, together. Examining the first elements, and then the second elements, etc.</p> <pre><code>list(zip(range(3), \"abc\"))\n</code></pre> <p><code>[(0, 'a'), (1, 'b'), (2, 'c')]</code></p> <p>'zip' is useful in many cases, and you can also use more than two lists (or other iterables).</p>"},{"location":"part_III/#exrecise","title":"Exrecise","text":"<p>I've implemented above from_roman with the latest things we've learn. Not sure this implementation is better. Up to you to decide. Take from it what you like. Nothing wrong with old good loops. One will often mix and match.</p> <p>Make sure you can follow what we've done here. Can you see why using 'reversed' was not required with this implementation?</p> <pre><code>def from_roman2(roman):\n\"\"\"\n    This function receives a roman number as a string and returns the number.\n    &gt;&gt;&gt; from_roman2(\"VII\")\n    7\n    &gt;&gt;&gt; from_roman2(\"IV\")\n    4\n    &gt;&gt;&gt; from_roman2(\"XIV\")\n    14\n    &gt;&gt;&gt; from_roman2(\"XVIII\")\n    18\n    &gt;&gt;&gt; from_roman2(\"MMM\")\n    ValueError                                Traceback (most recent call last)\n        ...\n    ValueError: Don't know to handle 'M'.    \n    \"\"\"\nif len(roman) &lt; 1:\nreturn 0\nmapping = {'I': 1, 'V': 5, 'X': 10}\nvalues = [mapping.get(c, None) for c in roman]\nif None in values:\nc = next(c for c, v in zip(roman, values) if v is None) # returns the (next) first occurrence\nraise ValueError(f\"Don't know to handle '{c}'.\")\n# the sign +1 or -1\nadd_or_sub = [1 if v1 &gt;= v2 else -1 for v1, v2 in zip(values[:-1], values[1:])]\nassert len(values) - 1 == len(add_or_sub) # make sure we do what we think we do\nadd_or_sub.append(+1) # right most element is added.\nreturn sum(v * s for v, s in zip(values, add_or_sub))\n</code></pre>"},{"location":"part_II_np/","title":"Part II (numpy)","text":"<p>We take a little break from pure Python, and introduce a very useful package numpy. It is not part of the standard library yet easily installed, for example with (below is done in an OS shell, it is not Python):</p> <pre><code>pip install numpy\n</code></pre> <p>If you're wokring with 'pip' or with 'conda' please go and install 'numpy'. For me, 'numpy' was already available with https://www.python.org/shell/. I've verified it with:</p> <pre><code>import numpy as np\nnp.__version__\n</code></pre> <p><code>'1.21.6'</code></p> <p>(Packages also have their version, which is also very important concept to wrap your head around. For now we are good.)</p> <p>We import the package and follow the convention to alias it np:</p> <pre><code>import numpy as np\ntype(np)\n</code></pre> <p><code>module</code></p> <p>Why did I say a package? A package may have multiple modules. We\u2019ll talk about it later.</p> <p>So why is it worth it to learn about 'numpy'? Well, first it is an example of yet another useful package. Python is great, yet it is really great thanks to the ecosystem around it. There are packages for data science, packages that are part of web frameworks, packages for developing games. In particular, 'numpy', appears almost always (at least with Python software I've played with).</p> <p>The theme of 'numpy' is linear algebra. For example, one can wrap a list into 'numpy.ndarray' (n-dimensional array).</p> <pre><code>arr = np.array([1, 2, 3])\narr.shape\n</code></pre> <p><code>(3,)</code></p> <p>len(arr) will also work and shall return 3.</p> <p>The 'shape' returns a tuple where each entry is the length of the relevant dimension. Note the comma in (3,). This is to distinguish this value, which is a tuple, from (3) which is just the scalar 3 after the expression is evaluated.</p> <p>An important observation is that while a simple list can contain heterogeneous values, a 'numpy' array is expected to hold values of the same type in all cells. In addition to many goodies that we'll see soon, 'numpy' is intended to make the calculations fast and vectorized. Vectorisation is a technique where special hardware manipulate multiple cells at the same time.</p> <p>To find the type of the elements themselves, use:</p> <p><pre><code>arr.dtype\n</code></pre> In this example it is <code>dtype('int64')</code>.</p> <p>To find the dimension of a 'numpy' array, one can do:</p> <pre><code>len(arr.shape)\n</code></pre> <p><code>1</code></p> <p>Here BTW we see that 'len' works also on a tuple.</p> <p>To find how many elements in a 'numpy' array, I would go for:</p> <pre><code>np.prod(arr.shape)\n</code></pre> <p><code>3</code></p> <p>Above, we see a nice utility function from 'numpy' that takes an iterable, in this case the tuple arr.shape, and returns the product of the elements.</p> <p>Let's go to the next dimension:</p> <pre><code>mat = np.array([[1, 2], [1, 0], [2, 1]]); mat\n</code></pre> <pre><code>array([[1, 2],\n       [1, 0],\n       [2, 1]])\n</code></pre> <p>We used ';' to separate two expressions. The last expression mat is what we see in the interactive shell. We see that we got a matrix with 3 rows and 2 columns.</p> <pre><code>len(mat.shape), np.prod(mat.shape)\n</code></pre> <p><code>(2, 6)</code></p> <p>Here we used ',' between the two expressions. This gave us the tuple (2, 6). The first element of the tuple is the dimention of mat and the other is the count of elements in mat (similar to what we've verified above for arr).</p> <p>A 2-dimentional 'numpy' array or, a \"matrix\" has two axes; 0 and 1. One axis is the rows and the other is the columns. Let's see that in action:</p> <pre><code>np.sum(mat), np.sum(mat, axis=0), np.sum(mat, axis=1)\n</code></pre> <p><code>(7, array([4, 3]), array([3, 1, 3]))</code></p> <p>We can see that without the axis parameter we get a scalar which is the sum of all the elements. With axis=0 the rows collapse and we get the summation per columns. With axis=1 the columns collapse, and we end up with as many entries in the result 'numpy' array as we had rows. </p> <p>Let's try the following advanced exercise. We're given a matrix. We return another matrix according to the following rules. If a cell in the input matrix is zero, the matching \"cell\" in the return matrix will be 3 by 3 zeros. Otherwise, a none zero value, will result with a matching \"cell\" of 3 by 3 ones. It will get soon clear when you'll see the example output.</p> <pre><code>def inflate(input_matrix):\nres = []\nfor row in range(0, input_matrix.shape[0]):\nres_row = []\nfor col in range(0, input_matrix.shape[1]):\nsubmatrix = input_matrix[row:row + 1, col:col + 1]\ntransformed = np.zeros((3, 3)) if submatrix == 0 else np.ones((3, 3))\nres_row.append(transformed)\nres.append(np.concatenate(res_row, axis=1))\nreturn np.concatenate(res, axis=0)\n</code></pre> <pre><code>array([[1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 0., 0., 0.],\n       [1., 1., 1., 0., 0., 0.],\n       [1., 1., 1., 0., 0., 0.],\n       [1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1.]])\n</code></pre> <p>Note that, on line 6 we access a submatrix (in this case just 1 by 1) using indices (similar to slicing in lists).</p> <p>The assignment to the variable transformed on line 7 needs a clarification. This is the equivalent of the ternary operator from C/C++. In C we have <code>cond ? val_when_true : val_when_false</code>. With Python this would be <code>val_when_true if cond else val_when_false</code>.</p> <p>Maybe there is a smarter way to achieve what was done above in the function inflate. That is what I came up with.</p> <p>And now it is your turn.</p>"},{"location":"part_II_np/#exercise","title":"Exercise","text":"<p>This course is originated in the Netherlands . Which means that we need to do something with a windmill. Here are some building blocks that may help.</p> <pre><code>np.tri(4)\n</code></pre> <pre><code>array([[1., 0., 0., 0.],\n       [1., 1., 0., 0.],\n       [1., 1., 1., 0.],\n       [1., 1., 1., 1.]])\n</code></pre> <pre><code>np.tri(4).T # transpose\n</code></pre> <pre><code>array([[1., 1., 1., 1.],\n       [0., 1., 1., 1.],\n       [0., 0., 1., 1.],\n       [0., 0., 0., 1.]])\n</code></pre> <pre><code>np.flip(np.tri(4), axis=0)\n</code></pre> <pre><code>array([[1., 1., 1., 1.],\n       [1., 1., 1., 0.],\n       [1., 1., 0., 0.],\n       [1., 0., 0., 0.]])\n</code></pre>"}]}